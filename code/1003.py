# -*- coding: utf-8 -*-
"""1003.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17himr9H5SDkjjChKe3ww_XqzvLFaJvie
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np
import torch
import torch.nn as nn
from tqdm.notebook import tqdm
from torch.utils.data import Dataset, DataLoader
from sklearn.model_selection import train_test_split
from types import SimpleNamespace
from sklearn.preprocessing import MinMaxScaler
import os

train_df = pd.read_csv('/content/drive/MyDrive/데이터·AI를 활용한 물가 예측 경진대회 : 농산물 가격을 중심으로/train/train.csv')
train_df

train_df.describe()

train_df.nunique()

train_산지공판장 = pd.read_csv('/content/drive/MyDrive/데이터·AI를 활용한 물가 예측 경진대회 : 농산물 가격을 중심으로/train/meta/TRAIN_산지공판장_2018-2021.csv')
train_산지공판장

train_전국도매 = pd.read_csv('/content/drive/MyDrive/데이터·AI를 활용한 물가 예측 경진대회 : 농산물 가격을 중심으로/train/meta/TRAIN_전국도매_2018-2021.csv')
train_전국도매

def filter_data(df):
    # 각 품목에 대한 필터링 조건 정의
    conditions = {
        '건고추': {'품종명': '화건', '거래단위': '30 kg', '등급': '상품'},
        '사과': {'품종명': ['홍로', '후지'], '거래단위': '10 개', '등급': '상품'},
        '감자': {'품종명': '감자 수미', '거래단위': '20키로상자', '등급': '상'},
        '배': {'품종명': '신고', '거래단위': '10 개', '등급': '상품'},
        '깐마늘(국산)': {'품종명': '깐마늘(국산)', '거래단위': '20 kg', '등급': '상품'},
        '무': {'품종명': '무', '거래단위': '20키로상자', '등급': '상'},
        '상추': {'품종명': '청', '거래단위': '100 g', '등급': '상품'},
        '배추': {'품종명': '배추', '거래단위': '10키로망대', '등급': '상'},
        '양파': {'품종명': '양파', '거래단위': '1키로', '등급': '상'},
        '대파': {'품종명': '대파(일반)', '거래단위': '1키로단', '등급': '상'}
    }

    # 조건에 맞는 행만 선택
    mask = pd.Series([False] * len(df))

    for 품목명, 조건 in conditions.items():
        # 각 열이 데이터프레임에 존재하는지 확인하고 필터링 조건 생성
        품종_조건 = df['품종명'].isin(조건['품종명']) if ('품종명' in df.columns and isinstance(조건['품종명'], list)) else (df['품종명'] == 조건['품종명']) if '품종명' in df.columns else True
        품목_조건 = (df['품목명'] == 품목명) if '품목명' in df.columns else True
        거래단위_조건 = (df['거래단위'] == 조건['거래단위']) if '거래단위' in df.columns else True
        등급_조건 = (df['등급'] == 조건['등급']) if '등급' in df.columns else True

        # 각 품목의 조건에 맞는 행만 True로 설정
        mask |= (품목_조건 & 품종_조건 & 거래단위_조건 & 등급_조건)

    # 최종적으로 조건에 맞는 행만 필터링
    filtered_df = df[mask]

    return filtered_df

filtered_train_df = filter_data(train_df)
filtered_train_df

filtered_train_산지공판장 = filter_data(train_산지공판장)
filtered_train_산지공판장

filtered_train_전국도매 = filter_data(train_전국도매)
filtered_train_전국도매

filtered_train_df = filtered_train_df.drop(columns=['품목명', '거래단위', '등급'])
filtered_train_df

def process_time_column(df, drop_original=True):
    # '시점' 열을 '년도', '월', '순'으로 분해
    df['년도'] = df['시점'].str[:4].astype(int)  # 년도 추출
    df['월'] = df['시점'].str[4:6].astype(int)   # 월 추출
    df['순'] = df['시점'].str[6:]                # 순 추출 ('상순', '중순', '하순')

    # '순'을 숫자로 매핑 (상순: 1, 중순: 2, 하순: 3)
    순_map = {'상순': 1, '중순': 2, '하순': 3}
    df['순'] = df['순'].map(순_map)

    # 계절 정보 추가 ('월'을 기준으로 계절을 구분)
    df['계절'] = df['월'].apply(lambda x: '봄' if x in [3, 4, 5] else
                                          '여름' if x in [6, 7, 8] else
                                          '가을' if x in [9, 10, 11] else
                                          '겨울')

    # 계절 원-핫 인코딩
    df = pd.get_dummies(df, columns=['계절'], prefix='계절')

    # '시점'과 '계절' 열 제거 (drop_original=True일 때만)
    if drop_original:
        df.drop(columns=['시점'], inplace=True)
    return df

filtered_train_df = process_time_column(filtered_train_df, drop_original=True)
filtered_train_df

filtered_train_df.to_csv('filtered_train_df.csv')

import torch
import torch.nn as nn

# 품종명 리스트 (고유 품종명 리스트)
품종명_list = ['화건', '홍로', '후지', '감자수미', '신고', '깐마늘(국산)', '무', '청', '배추', '양파', '대파(일반)']

# 품종명을 정수 인코딩
품종명_to_index = {품종: idx for idx, 품종 in enumerate(품종명_list)}
filtered_train_df.loc[:, '품종명_encoded'] = filtered_train_df['품종명'].map(품종명_to_index)

# 임베딩 레이어 정의 (품종명 고유 개수와 임베딩 차원 수)
embedding_dim = 4
품종명_unique_count = len(품종명_list)
embedding_layer = nn.Embedding(품종명_unique_count, embedding_dim)

# 임베딩 벡터를 배치로 처리하여 데이터프레임에 추가
batch_size = 256  # 배치 크기 조정
embedding_columns = [f'품종명_embedded_{i}' for i in range(embedding_dim)]

for col in embedding_columns:
    filtered_train_df.loc[:, col] = 0.0  # 임베딩 열 초기화

with torch.no_grad():  # 학습이 아닌 예측 단계에서는 그래디언트 계산이 필요 없으므로 비활성화
    for start in range(0, len(filtered_train_df), batch_size):
        end = min(start + batch_size, len(filtered_train_df))  # 슬라이싱 범위를 데이터 길이에 맞게 설정
        input_tensor = torch.tensor(filtered_train_df['품종명_encoded'].values[start:end], dtype=torch.long)
        embedding_vectors = embedding_layer(input_tensor)

        # 임베딩 벡터를 데이터프레임에 추가 (4차원 벡터를 각각 별도의 열로 추가)
        for i in range(embedding_dim):
            filtered_train_df.loc[start:end, f'품종명_embedded_{i}'] = embedding_vectors[:, i].numpy()

# 기존 품종명 열을 drop
filtered_train_df.drop(columns=['품종명', '품종명_encoded'], inplace=True)

# 결과 확인
filtered_train_df.head()